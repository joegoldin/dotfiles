diff --git a/src/main/controllers/TabController.js b/src/main/controllers/TabController.js
index c03f6f1..d34c5e0 100644
--- a/src/main/controllers/TabController.js
+++ b/src/main/controllers/TabController.js
@@ -78,6 +78,9 @@ class TabController {
       log.error(`Tab ${this.tabId}: Error setting spell checker languages:`, err);
     }
 
+    // Ensure background tabs load fully so they're ready when switched to
+    this.webContentsView.webContents.backgroundThrottling = false;
+
     log.debug(`WebContentsView created for tab: ${this.tabId}`);
   }
 
@@ -87,6 +90,57 @@ class TabController {
   setupEventListeners() {
     const { webContents } = this.webContentsView;
 
+    // Keyboard shortcuts for tab management
+    webContents.on('before-input-event', (event, input) => {
+      if (input.type !== 'keyDown' || !input.control || input.alt) return;
+
+      // Ctrl+T: open a new tab with Notion search active
+      if (!input.shift && input.key === 't') {
+        event.preventDefault();
+        const TabManager = require('../managers/TabManager');
+        const tabManager = TabManager.getInstance();
+        const AppController = require('./AppController');
+        const appController = AppController.getInstance();
+        const windowController = appController.windowControllers.get(this.windowId);
+        if (windowController) {
+          const newTab = tabManager.createTab({
+            windowId: this.windowId,
+            url: 'https://www.notion.so',
+            title: 'New Tab',
+            makeActive: true,
+          });
+          windowController.setActiveTab(newTab);
+          // Once the page finishes loading, trigger Ctrl+K to open search
+          newTab.webContentsView.webContents.once('did-finish-load', () => {
+            newTab.webContentsView.webContents.sendInputEvent({ type: 'keyDown', keyCode: 'k', modifiers: ['control'] });
+            newTab.webContentsView.webContents.sendInputEvent({ type: 'keyUp', keyCode: 'k', modifiers: ['control'] });
+          });
+        }
+      }
+
+      // Ctrl+W: close current tab (or close window if last tab)
+      if (!input.shift && input.key === 'w') {
+        event.preventDefault();
+        const TabManager = require('../managers/TabManager');
+        const tabManager = TabManager.getInstance();
+        const AppController = require('./AppController');
+        const appController = AppController.getInstance();
+        const windowController = appController.windowControllers.get(this.windowId);
+        if (!windowController) return;
+        const tabId = this.tabId;
+        tabManager.destroyTab(tabId);
+        const state = this.store.getState();
+        const windowState = state.windows.windows[this.windowId];
+        if (windowState && windowState.tabIds.length > 0) {
+          const nextTabId = windowState.tabIds[0];
+          windowController.switchToTab(nextTabId);
+        } else {
+          const bw = windowController.getInternalBrowserWindow();
+          if (bw) bw.close();
+        }
+      }
+    });
+
     // Page title updated
     webContents.on('page-title-updated', (event, title) => {
       event.preventDefault(); // Prevent default title setting
@@ -125,6 +179,25 @@ class TabController {
 
       // Inject custom CSS after page loads
       this.injectCustomCSS();
+
+      // Prevent middle-click paste on Linux (X11 primary selection)
+      // while preserving middle-click-on-link to open in new tab
+      if (process.platform === 'linux') {
+        webContents.executeJavaScript(`
+          document.addEventListener('mousedown', function(e) {
+            if (e.button !== 1) return;
+            e.preventDefault();
+            var el = e.target;
+            while (el && el !== document.documentElement) {
+              if (el.tagName === 'A' && el.href) {
+                window.open(el.href, '_blank');
+                return;
+              }
+              el = el.parentElement;
+            }
+          }, true);
+        `).catch(() => {});
+      }
     });
 
     // Navigation started
@@ -162,8 +235,8 @@ class TabController {
       }
     });
 
-    // Handle external links - allow Notion domains, open others externally
-    webContents.setWindowOpenHandler(({ url }) => {
+    // Handle external links - open Notion domains in new tab, others externally
+    webContents.setWindowOpenHandler(({ url, disposition }) => {
       const parsedUrl = new URL(url);
 
       // Check if URL is a Notion domain (notion.so or notion.com)
@@ -175,16 +248,39 @@ class TabController {
         parsedUrl.hostname === 'www.notion.com' ||
         parsedUrl.hostname.endsWith('.notion.com');
 
-      if (isNotionDomain) {
-        // Allow Notion links to open in new tab within app
-        log.debug(`Tab ${this.tabId}: Allowing new window for Notion URL: ${url}`);
-        return { action: 'allow' };
-      } else {
+      if (!isNotionDomain) {
         // Open non-Notion links in external browser
         require('electron').shell.openExternal(url);
         log.debug(`Tab ${this.tabId}: Opening external URL in browser: ${url}`);
         return { action: 'deny' };
       }
+
+      // Explicit new-window requests: let Electron create a new window
+      if (disposition === 'new-window') {
+        log.debug(`Tab ${this.tabId}: Allowing new window for Notion URL: ${url}`);
+        return { action: 'allow' };
+      }
+
+      // Everything else (foreground-tab, background-tab, default): open in a tab
+      log.debug(`Tab ${this.tabId}: Opening Notion URL in new tab (disposition=${disposition}): ${url}`);
+      setImmediate(() => {
+        const TabManager = require('../managers/TabManager');
+        const tabManager = TabManager.getInstance();
+        const AppController = require('./AppController');
+        const appController = AppController.getInstance();
+        const windowController = appController.windowControllers.get(this.windowId);
+        if (windowController) {
+          const makeActive = disposition !== 'background-tab';
+          const newTab = tabManager.createTab({
+            windowId: this.windowId,
+            url: url,
+            title: 'Loading...',
+            makeActive,
+          });
+          if (makeActive) windowController.setActiveTab(newTab);
+        }
+      });
+      return { action: 'deny' };
     });
 
     // Allow navigation within Notion, block external sites
diff --git a/src/main/controllers/WindowController.js b/src/main/controllers/WindowController.js
index 3c239af..ee4320c 100644
--- a/src/main/controllers/WindowController.js
+++ b/src/main/controllers/WindowController.js
@@ -26,9 +26,9 @@ class WindowController {
     this.createBrowserWindow();
     this.createTabBarView();
     this.setupBrowserWindowListeners();
-    this.createInitialTab();
 
-    // Dispatch action to add this window to the Redux store
+    // Dispatch action to add this window to the Redux store BEFORE creating
+    // the initial tab, so that addTabToWindow/setActiveTabForWindow can find it.
     this.store.dispatch(addWindow({
       windowId: this.windowId,
       bounds: this.browserWindow.getBounds(), // Get actual bounds after creation
@@ -37,6 +37,8 @@ class WindowController {
       isFocused: this.browserWindow.isFocused(), // Check initial focus state
     }));
 
+    this.createInitialTab();
+
     // Show window after everything is set up
     // We don't use ready-to-show because we're using WebContentsView
     this.show();
@@ -55,8 +57,18 @@ class WindowController {
       return path.join(__dirname, '../../../assets/icon.png');
     };
 
+    // Center on primary display
+    const { screen } = require('electron');
+    const primaryDisplay = screen.getPrimaryDisplay();
+    const { width: screenW, height: screenH } = primaryDisplay.workAreaSize;
+    const winW = this.initialBounds.width || 1200;
+    const winH = this.initialBounds.height || 800;
+
     this.browserWindow = new BrowserWindow({
-      ...this.initialBounds,
+      width: winW,
+      height: winH,
+      x: Math.round((screenW - winW) / 2) + primaryDisplay.workArea.x,
+      y: Math.round((screenH - winH) / 2) + primaryDisplay.workArea.y,
       minWidth: 600,
       minHeight: 400,
       icon: getIconPath(),
@@ -101,6 +113,30 @@ class WindowController {
     // Note: ready-to-show doesn't fire reliably when using WebContentsView
     // We'll show the window manually after setup
 
+    // Save session state before window closes so tabs can be restored
+    this.browserWindow.on('close', () => {
+      const TabManager = require('../managers/TabManager');
+      const tabManager = TabManager.getInstance();
+      const tabs = tabManager.getTabsForWindow(this.windowId);
+      const Store = require('electron-store');
+      const sessionStore = new Store();
+
+      const state = this.store.getState();
+      const windowState = state.windows.windows[this.windowId];
+      const activeTabId = windowState?.activeTabId;
+
+      const sessionTabs = tabs
+        .filter(tab => !tab.isTabDestroyed())
+        .map(tab => ({
+          url: tab.getURL() || tab.initialUrl,
+          active: tab.tabId === activeTabId,
+        }));
+
+      if (sessionTabs.length > 0) {
+        sessionStore.set('session', { tabs: sessionTabs });
+      }
+    });
+
     this.browserWindow.on('closed', () => {
       log.info(`Window ${this.windowId} closed`);
       this.store.dispatch(removeWindow(this.windowId));
@@ -233,16 +269,34 @@ class WindowController {
   createInitialTab() {
     const TabManager = require('../managers/TabManager');
     const tabManager = TabManager.getInstance();
+    const Store = require('electron-store');
+    const sessionStore = new Store();
+    const session = sessionStore.get('session');
+    sessionStore.delete('session');
 
-    log.info(`Creating initial tab for window ${this.windowId}`);
-    const tabController = tabManager.createTab({
-      windowId: this.windowId,
-      url: this.initialUrl,
-      title: this.initialTitle,
-      makeActive: true,
-    });
-
-    this.setActiveTab(tabController);
+    if (session && session.tabs && session.tabs.length > 0) {
+      log.info(`Restoring ${session.tabs.length} tabs for window ${this.windowId}`);
+      let activeTab = null;
+      session.tabs.forEach((savedTab) => {
+        const tabController = tabManager.createTab({
+          windowId: this.windowId,
+          url: savedTab.url,
+          title: 'Loading...',
+          makeActive: savedTab.active,
+        });
+        if (savedTab.active) activeTab = tabController;
+      });
+      this.setActiveTab(activeTab || tabManager.getTabsForWindow(this.windowId)[0]);
+    } else {
+      log.info(`Creating initial tab for window ${this.windowId}`);
+      const tabController = tabManager.createTab({
+        windowId: this.windowId,
+        url: this.initialUrl,
+        title: this.initialTitle,
+        makeActive: true,
+      });
+      this.setActiveTab(tabController);
+    }
   }
 
   /**
diff --git a/src/main/index.js b/src/main/index.js
index 0fd6b22..17c1951 100644
--- a/src/main/index.js
+++ b/src/main/index.js
@@ -637,7 +637,7 @@ ipcMain.handle('tab-bar:close-tab', async (event, tabId) => {
   // Destroy the tab
   tabManager.destroyTab(tabId);
 
-  // If this was the active tab, switch to another tab
+  // If this was the active tab, switch to another tab or close the window
   if (windowController && windowController.currentActiveTabController?.tabId === tabId) {
     const state = reduxStore.getState();
     const windowState = state.windows.windows[windowId];
@@ -646,6 +646,10 @@ ipcMain.handle('tab-bar:close-tab', async (event, tabId) => {
       // Switch to first available tab
       const nextTabId = windowState.tabIds[0];
       windowController.switchToTab(nextTabId);
+    } else {
+      // No tabs left â€” close the window
+      const bw = windowController.getInternalBrowserWindow();
+      if (bw) bw.close();
     }
   }
 
@@ -671,6 +675,7 @@ ipcMain.handle('tab-bar:switch-tab', async (event, tabId) => {
   const windowController = appController.windowControllers.get(tabController.windowId);
   if (windowController) {
     windowController.switchToTab(tabId);
+    notifyTabBarUpdate(tabController.windowId);
     return { success: true };
   }
 
diff --git a/src/renderer/tab-bar/index.html b/src/renderer/tab-bar/index.html
index add4544..4d63486 100644
--- a/src/renderer/tab-bar/index.html
+++ b/src/renderer/tab-bar/index.html
@@ -319,6 +319,14 @@
       background-color: var(--bg-tab-hover);
     }
 
+    .tab.dragging {
+      opacity: 0.4;
+    }
+
+    .tab.drag-over {
+      border-left: 2px solid var(--accent-color);
+    }
+
     .tab.active {
       background-color: var(--bg-tab-active);
       border-bottom: 2px solid var(--accent-color);
diff --git a/src/renderer/tab-bar/renderer.js b/src/renderer/tab-bar/renderer.js
index 3f8a211..c6a3ca5 100644
--- a/src/renderer/tab-bar/renderer.js
+++ b/src/renderer/tab-bar/renderer.js
@@ -93,6 +93,7 @@ function renderTab(tab) {
   return `
     <div class="tab ${isActive ? 'active' : ''} ${isPinned ? 'pinned' : ''}"
          data-tab-id="${tab.tabId}"
+         draggable="true"
          title="${escapeHtml(tab.title || 'Untitled')}">
       ${faviconHtml}
       <span class="tab-title">${escapeHtml(title)}</span>
@@ -120,6 +121,59 @@ function addEventListeners() {
     });
   });
 
+  // Middle-click on tab - close tab
+  document.querySelectorAll('.tab').forEach(tabEl => {
+    tabEl.addEventListener('auxclick', (e) => {
+      if (e.button === 1) {
+        e.preventDefault();
+        e.stopPropagation();
+        const tabId = tabEl.dataset.tabId;
+        window.tabBarAPI.closeTab(tabId);
+      }
+    });
+  });
+
+  // Drag-and-drop tab reordering
+  document.querySelectorAll('.tab').forEach(tabEl => {
+    tabEl.addEventListener('dragstart', (e) => {
+      e.dataTransfer.effectAllowed = 'move';
+      e.dataTransfer.setData('text/plain', tabEl.dataset.tabId);
+      tabEl.classList.add('dragging');
+    });
+    tabEl.addEventListener('dragend', () => {
+      tabEl.classList.remove('dragging');
+      document.querySelectorAll('.tab.drag-over').forEach(el => el.classList.remove('drag-over'));
+    });
+    tabEl.addEventListener('dragover', (e) => {
+      e.preventDefault();
+      e.dataTransfer.dropEffect = 'move';
+      const dragging = document.querySelector('.tab.dragging');
+      if (dragging && dragging !== tabEl) {
+        tabEl.classList.add('drag-over');
+      }
+    });
+    tabEl.addEventListener('dragleave', () => {
+      tabEl.classList.remove('drag-over');
+    });
+    tabEl.addEventListener('drop', (e) => {
+      e.preventDefault();
+      tabEl.classList.remove('drag-over');
+      const draggedTabId = e.dataTransfer.getData('text/plain');
+      const targetTabId = tabEl.dataset.tabId;
+      if (draggedTabId && draggedTabId !== targetTabId) {
+        // Compute new order by moving dragged tab before target
+        const tabIds = tabs.map(t => t.tabId);
+        const fromIdx = tabIds.indexOf(draggedTabId);
+        if (fromIdx !== -1) {
+          tabIds.splice(fromIdx, 1);
+          const toIdx = tabIds.indexOf(targetTabId);
+          tabIds.splice(toIdx, 0, draggedTabId);
+          window.tabBarAPI.reorderTabs(windowId, tabIds);
+        }
+      }
+    });
+  });
+
   // Close button click
   document.querySelectorAll('.close-btn').forEach(btn => {
     btn.addEventListener('click', (e) => {
