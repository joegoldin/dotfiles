#!/usr/bin/env python3
import argparse
import os
import re
import subprocess
import sys
import tempfile
from pathlib import Path


def get_vtt(url: str, arg: str) -> str | None:
    """Download VTT subtitles using yt-dlp."""
    with tempfile.TemporaryDirectory() as temp_dir:
        try:
            result = subprocess.run(
                [
                    'yt-dlp',
                    '--skip-download',
                    arg,
                    '--sub-lang', 'en',
                    '--sub-format', 'vtt',
                    '-o', os.path.join(temp_dir, '%(id)s.%(ext)s'),
                    url
                ],
                capture_output=True,
                text=True,
                check=False
            )

            if result.returncode != 0:
                return None

            # Find the VTT file
            for file in Path(temp_dir).iterdir():
                if file.suffix == '.vtt':
                    return file.read_text(encoding='utf-8')

            return None

        except FileNotFoundError:
            print("Error: yt-dlp not found. Install with: pip install yt-dlp", file=sys.stderr)
            sys.exit(1)
        except Exception as e:
            print(f"Error downloading subtitles: {e}", file=sys.stderr)
            return None


def clean_text(text: str) -> str:
    """Clean subtitle text by removing HTML tags and extra whitespace."""
    # Remove HTML/XML tags
    text = re.sub(r'<[^>]+>', '', text)
    # Remove multiple whitespace
    text = ' '.join(text.split())
    # Remove semicolons
    text = text.replace(' ;', '').replace(';', '')
    return text.strip()


def parse_vtt(vtt_content: str) -> list[str]:
    """
    Parse VTT content manually without external dependencies.

    VTT format:
    WEBVTT

    00:00:00.000 --> 00:00:02.000
    First subtitle line

    00:00:02.000 --> 00:00:04.000
    Second subtitle line
    """
    lines = []
    current_cue_lines = []
    in_cue = False

    for line in vtt_content.split('\n'):
        line = line.strip()

        # Skip WEBVTT header and metadata
        if line.startswith('WEBVTT') or line.startswith('Kind:') or line.startswith('Language:'):
            continue

        # Skip NOTE blocks
        if line.startswith('NOTE'):
            continue

        # Check if this is a timestamp line (cue timing)
        if '-->' in line:
            # Save previous cue if exists
            if current_cue_lines:
                combined = ' '.join(current_cue_lines)
                cleaned = clean_text(combined)
                if cleaned:
                    lines.append(cleaned)
                current_cue_lines = []
            in_cue = True
            continue

        # Skip empty lines or cue identifiers
        if not line:
            in_cue = False
            continue

        # Skip cue identifiers (numbers)
        if line.isdigit():
            continue

        # This is subtitle text - accumulate it
        if in_cue:
            current_cue_lines.append(line)

    # Don't forget the last cue
    if current_cue_lines:
        combined = ' '.join(current_cue_lines)
        cleaned = clean_text(combined)
        if cleaned:
            lines.append(cleaned)

    return lines


def extract_new_words(lines: list[str]) -> list[str]:
    """
    Extract only the new words from YouTube's overlapping subtitles.
    YouTube auto-generated captions repeat previous text in each cue.
    """
    if not lines:
        return []

    result = []
    seen_text = ""

    for line in lines:
        # Skip if this is exactly the same as what we just saw
        if line == seen_text:
            continue

        # If this line starts with what we've already seen, extract the new part
        if seen_text and line.startswith(seen_text):
            new_part = line[len(seen_text):].strip()
            if new_part:
                result.append(new_part)
            seen_text = line
        # Check if the current line is contained in what we've seen (sometimes it backtracks)
        elif seen_text and seen_text.endswith(line):
            # Skip this duplicate
            continue
        else:
            # Check if this is a continuation of the previous text
            # (Sometimes YouTube subs have the last few words repeated)
            words_current = line.split()
            words_seen = seen_text.split()

            # Find longest common suffix between seen_text and prefix of current line
            overlap_found = False
            for i in range(1, min(len(words_seen), len(words_current)) + 1):
                if words_seen[-i:] == words_current[:i]:
                    # Found overlap, extract new words
                    new_words = words_current[i:]
                    if new_words:
                        result.append(' '.join(new_words))
                        overlap_found = True
                        seen_text = line
                        break

            if not overlap_found:
                # No overlap, this is completely new text
                result.append(line)
                seen_text = line

    return result


def vtt_lines(vtt_content: str) -> list[str]:
    """
    Convert VTT content to a list of unique subtitle lines.

    YouTube's subtitles have some weirdnesses which this function tries to
    handle. It probably doesn't do it perfectly.
    """
    # Parse VTT content
    raw_lines = parse_vtt(vtt_content)

    # Extract only new words (handles YouTube's overlapping text)
    return extract_new_words(raw_lines)


def main():
    parser = argparse.ArgumentParser(description='Download and extract subtitles from YouTube videos')
    parser.add_argument('url', help='YouTube video URL')
    args = parser.parse_args()

    # Try manual subtitles first
    vtt_content = get_vtt(args.url, '--write-sub')

    # Fall back to auto-generated subtitles
    if not vtt_content:
        vtt_content = get_vtt(args.url, '--write-auto-sub')

    if not vtt_content:
        print("Error: no subs found", file=sys.stderr)
        sys.exit(1)

    # Extract and print lines
    lines = vtt_lines(vtt_content)
    for line in lines:
        print(line)


if __name__ == '__main__':
    main()
